<?xml version="1.0" encoding="UTF-8"?>
<model version="5.2.5" links="0">
 <framework name="qpcpp"/>
 <package name="project" stereotype="0x04" namespace="PFPP::">
  <package name="AOs" stereotype="0x02" namespace="AO::">
   <class name="Mgr_AO" superclass="qpcpp::QActive">
    <documentation>The top manager AO for the project.

This is where all the feeding actions are taken, based on calendar events and input buttons.</documentation>
    <attribute name="mDeferredEventQueueSto[4] {}" type="const QP::QEvt*" visibility="0x02" properties="0x00">
     <documentation>Queue of deferred events.</documentation>
    </attribute>
    <attribute name="mDeferredEventQueue {}" type="QP::QEQueue" visibility="0x02" properties="0x00">
     <documentation>The queue of deferred events.</documentation>
    </attribute>
    <attribute name="mFeedTimer" type="QP::QTimeEvt" visibility="0x02" properties="0x00">
     <documentation>Timer for fixed and time-capped feeding periods.</documentation>
    </attribute>
    <attribute name="mMotorControl" type="std::unique_ptr&lt;Drivers::IMotorControl&gt;" visibility="0x02" properties="0x00">
     <documentation>Motor controller for activating feeder.</documentation>
    </attribute>
    <attribute name="mFeedCfg {}" type="FeedCfg" visibility="0x02" properties="0x00">
     <documentation>A pointer to the Feeder configuration record.</documentation>
    </attribute>
    <attribute name="mDate {}" type="std::chrono::year_month_day" visibility="0x02" properties="0x00">
     <documentation>A local copy of current date from RTCC or system time.</documentation>
    </attribute>
    <attribute name="mTime {}" type="std::chrono::minutes" visibility="0x02" properties="0x00">
     <documentation>A local copy of current time from RTCC or system time.</documentation>
    </attribute>
    <attribute name="mLogCategory {&quot;PFPP&quot;}? 0" type="char const *" visibility="0x02" properties="0x00">
     <documentation>The string representing the log categories from this AO.</documentation>
    </attribute>
    <attribute name="mLogThreshold {LogLevel::prio::INFO}? 0" type="LogLevel::prio" visibility="0x02" properties="0x00">
     <documentation>The threshold under which events are displayed.</documentation>
    </attribute>
    <attribute name="mLogger? 0" type="std::shared_ptr&lt;Logger&gt;" visibility="0x02" properties="0x00">
     <documentation>The logger source object.</documentation>
    </attribute>
    <attribute name="mTicksPerSecond? 0" type="unsigned int" visibility="0x02" properties="0x00">
     <documentation>System ticks per second.</documentation>
    </attribute>
    <attribute name="mToTicksFct" type="const ToTicksFct&amp;" visibility="0x02" properties="0x00">
     <documentation>Function to convert timebase to event counter ticks.</documentation>
    </attribute>
    <operation name="Mgr_AO" type="" visibility="0x00" properties="0x00">
     <documentation>Ctor</documentation>
     <parameter name="aMotorControl" type="std::unique_ptr&lt;Drivers::IMotorControl&gt;"/>
     <parameter name="aFeedCfg" type="const FeedCfg&amp;"/>
     <parameter name="aToTicksFct" type="const ToTicksFct&amp;"/>
     <code>    : QP::QActive(Q_STATE_CAST(&amp;PFPP::AO::Mgr_AO::initial))
    , mFeedTimer{this, FEED_MGR_TIMEOUT_SIG, 0U}
    , mMotorControl{std::move(aMotorControl)}
    , mFeedCfg{aFeedCfg}
    , mToTicksFct{aToTicksFct}

// Ctor body.
//mLogger-&gt;AddCategory(mLogCategory, LOG_EVENT_SIG, mLogThreshold);
//mLogger-&gt;AddSink(mLogCategory, this);</code>
    </operation>
    <operation name="StartTimedFeed" type="void" visibility="0x02" properties="0x00">
     <documentation>Starts a timed feeding period.</documentation>
     <parameter name="aFeedTime" type="const QP::QTimeEvtCtr"/>
     <code>mFeedTimer.armX(aFeedTime);
StartFeeder();</code>
    </operation>
    <operation name="StopTimedFeed" type="void" visibility="0x02" properties="0x00">
     <documentation>Stop timed feeding period.</documentation>
     <code>StopFeeder();
mFeedTimer.disarm();</code>
    </operation>
    <operation name="StartFeeder" type="void" visibility="0x02" properties="0x00">
     <specifiers>const</specifiers>
     <documentation>Start whatever mechanism used to distribute food.</documentation>
     <code>// Start motor.
mMotorControl-&gt;TurnOnCW();</code>
    </operation>
    <operation name="StopFeeder" type="void" visibility="0x02" properties="0x00">
     <specifiers>const</specifiers>
     <documentation>Stops whatever mechanism is used to distribute food.</documentation>
     <code>// Stop feeder.
mMotorControl-&gt;TurnOff();</code>
    </operation>
    <operation name="GetManualWaitPeriod" type="QP::QTimeEvtCtr" visibility="0x02" properties="0x00">
     <specifiers>const</specifiers>
     <documentation>Returns the manual waiting period as per FeedCfgRec if any, or default value.</documentation>
     <code>//return mFeedCfgRec-&gt;GetManualFeedWaitPeriod() * BSP::TICKS_PER_SEC;
return mToTicksFct(mFeedCfg.mManualFeedWaitPeriod);</code>
    </operation>
    <operation name="GetManualMaxFeedPeriod" type="QP::QTimeEvtCtr" visibility="0x02" properties="0x00">
     <specifiers>const</specifiers>
     <documentation>Returns the manual feed period as per FeedCfgRec if any, or default value.</documentation>
     <code>//return mFeedCfgRec-&gt;GetManualFeedMaxFeedPeriod() * BSP::TICKS_PER_SEC;
return mToTicksFct(mFeedCfg.mManualFeedMaxFeedPeriod );</code>
    </operation>
    <operation name="GetTimedFeedPeriod" type="QP::QTimeEvtCtr" visibility="0x02" properties="0x00">
     <specifiers>const</specifiers>
     <documentation>Returns the timed feed period as per FeedCfgRec if any, or default value.</documentation>
     <code>//return mFeedCfgRec-&gt;GetTimedFeedPeriod() * BSP::TICKS_PER_SEC;
return mToTicksFct(mFeedCfg.mTimedFeedPeriod);</code>
    </operation>
    <operation name="IsManualFeedAllowed" type="bool" visibility="0x02" properties="0x00">
     <specifiers>const</specifiers>
     <documentation>Returns if manual feed is allowed or not.</documentation>
     <code>//return mFeedCfgRec-&gt;IsManualFeedEnable();
return mFeedCfg.mIsManualFeedEnable;</code>
    </operation>
    <operation name="IsTimedFeedAllowed" type="bool" visibility="0x02" properties="0x00">
     <specifiers>const</specifiers>
     <documentation>Returns if timed feed is allowed or not.</documentation>
     <code>//return mFeedCfgRec-&gt;IsTimedFeedEnable();
return mFeedCfg.mIsTimedFeedEnable;</code>
    </operation>
    <operation name="DisplayFeedTime? 0" type="void" visibility="0x02" properties="0x00">
     <documentation>Sends a &quot;Display Text&quot; signal to show last feeding time.</documentation>
     <code>auto const lDate{mDate.ToStr()};
auto const lTime = mTime.ToStr();
auto const lTimeAndDate = lDate + ' ' + lTime;
Display::Event::DisplayText * const lTextEvent = Q_NEW(
    Display::Event::DisplayText,
    DISPLAY_TEXT_SIG,
    0, 60,
    0xF,
    lTimeAndDate.c_str(),
    true
);
QP::QF::PUBLISH(lTextEvent, this);
</code>
    </operation>
    <operation name="PrintEvent?def USE_RTT" type="void" visibility="0x02" properties="0x00">
     <specifiers>const</specifiers>
     <documentation>Event sink: print to SEGGER RTT.</documentation>
     <parameter name="aLogEvent" type="Logging::Event::LogEntry const &amp;"/>
     <code>auto const lDateStr = mDate.ToStr();
auto const lTimeStr = mTime.ToStr();
static constexpr unsigned int sBufferIndex = 0;
int const lLen = SEGGER_RTT_printf(
    sBufferIndex,
    &quot;%s @%s: %s in file %s, function %s at line %d. %s::%s\n&quot;,
    lDateStr.c_str(),
    lTimeStr.c_str(),
    LogLevel::ToStr(aLogEvent.mLogLevel),
    aLogEvent.mFileStr,
    aLogEvent.mFunctionStr,
    aLogEvent.mLine,
    aLogEvent.mCategoryStr,
    &amp;aLogEvent.mMsg[0]
);

// Do nothing with returned Len for now.
static_cast&lt;void&gt;(lLen);</code>
    </operation>
    <operation name="FireTimedFeedEvt" type="void" visibility="0x00" properties="0x01">
     <documentation>Fires an event to signal timed feed.
Used as a callback to RTCC calendar alarm event.</documentation>
     <parameter name="me" type="QP::QActive*"/>
     <code>static const QP::QEvt sTimedFeedEvt {
    FEED_MGR_TIMED_FEED_CMD_SIG, 0, 0
};

me-&gt;POST(&amp;sTimedFeedEvt, me);
</code>
    </operation>
    <statechart properties="0x02">
     <initial target="../1">
      <action brief="Init();">static_cast&lt;void&gt;(e);
StopFeeder();

// Initialize the QF queue for deferred feed requests.
mDeferredEventQueue.init(mDeferredEventQueueSto, Q_DIM(mDeferredEventQueueSto));

// Subscribe to signals if any.
//subscribe(RTCC_CALENDAR_EVENT_ALARM_SIG);
subscribe(RTCC_TICK_SIG);
subscribe(FEED_MGR_MANUAL_FEED_CMD_SIG);
subscribe(FEED_MGR_TIMED_FEED_CMD_SIG);
//subscribe(LWIP_IP_CHANGED_SIG);
//subscribe(LWIP_SYSTEM_TIME_UPDATE_SIG);
</action>
      <initial_glyph conn="4,6,5,0,8,6">
       <action box="0,-2,10,2"/>
      </initial_glyph>
     </initial>
     <state name="Running">
      <documentation>Top state.</documentation>
      <entry brief="DisplayFrame();">#if 0
char const *lFrameStr = &quot;Last feed time:&quot;;
Display::Event::DisplayText * const lFrameEvent = Q_NEW(
    Display::Event::DisplayText,
    DISPLAY_TEXT_SIG,
    0, 50,
    0xF,
    lFrameStr,
    false
);
QP::QF::PUBLISH(lFrameEvent, this);
#endif</entry>
      <initial target="../10">
       <initial_glyph conn="32,18,5,0,6,6">
        <action box="0,-2,10,2"/>
       </initial_glyph>
      </initial>
      <tran trig="FEED_MGR_TIMEOUT" target="../10">
       <tran_glyph conn="4,28,3,3,28">
        <action box="0,-2,22,2"/>
       </tran_glyph>
      </tran>
      <tran trig="RTCC_CALENDAR_EVENT_ALARM? 0" target="../12">
       <tran_glyph conn="4,88,3,3,28">
        <action box="0,-2,28,4"/>
       </tran_glyph>
      </tran>
      <tran trig="FEED_MGR_MANUAL_FEED_CMD">
       <action brief="GetState();">//PFPP::Event::Mgr::ManualFeedCmd const * const lEvent = static_cast&lt;PFPP::Event::Mgr::ManualFeedCmd const *&gt;(e);
const auto lEvent {static_cast&lt;const PFPP::Event::Mgr::ManualFeedCmd*&gt;(e)};
</action>
       <choice target="../../11">
        <guard brief="(IsAllowed == true) &amp;&amp; (State == On)">(IsManualFeedAllowed()) &amp;&amp; (lEvent-&gt;mIsActive == true)</guard>
        <choice_glyph conn="18,46,5,3,14">
         <action box="0,-2,24,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../10">
        <guard brief="else"/>
        <choice_glyph conn="18,46,4,3,-16,14">
         <action box="0,-16,10,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="4,46,3,-1,14">
        <action box="0,1,25,2"/>
       </tran_glyph>
      </tran>
      <tran trig="FEED_MGR_TIMED_FEED_CMD">
       <choice target="../../12">
        <guard brief="IsAllowed == true">IsTimedFeedAllowed()</guard>
        <choice_glyph conn="18,94,5,3,14">
         <action box="1,0,13,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="4,94,3,-1,14">
        <action box="0,-2,26,2"/>
       </tran_glyph>
      </tran>
      <tran trig="RTCC_TIME_TICK_ALARM? 0">
       <action brief="^DISPLAY_TEXT(Time, Date)">RTCC::Event::TimeAndDate const * const lEvent = static_cast&lt;RTCC::Event::TimeAndDate const *&gt;( e );
mDate = lEvent-&gt;mDate;
mTime = lEvent-&gt;mTime;

auto const lDateStr = lEvent-&gt;mDate.ToStr();
Display::Event::DisplayText * const lDateChangedEvent = Q_NEW(
    Display::Event::DisplayText,
    DISPLAY_TEXT_SIG,
    0, 10,
    0xF,
    lDateStr.c_str(),
    false
);
QP::QF::PUBLISH(lDateChangedEvent, this);

auto const lTimeStr = lEvent-&gt;mTime.ToStr();
Display::Event::DisplayText * const lTimeChangedEvent = Q_NEW(
    Display::Event::DisplayText,
    DISPLAY_TEXT_SIG,
    0, 20,
    0xF,
    lTimeStr.c_str(),
    false
);
QP::QF::PUBLISH(lTimeChangedEvent, this);</action>
       <tran_glyph conn="4,106,3,-1,50">
        <action box="0,-2,52,2"/>
       </tran_glyph>
      </tran>
      <tran trig="LWIP_IP_CHANGED? 0">
       <action brief="^DISPLAY_TEXT(IPAddress), ^LOG_ENTRY;">LwIP::Event::IPAddressChanged const * const lEvent = static_cast&lt;LwIP::Event::IPAddressChanged const *&gt;( e );
char lIPAddressStr[32]{0};
// Erase previous IP address, in case this one is longer.
memset(&amp;lIPAddressStr[0], ' ', 15);
Display::Event::DisplayText * const lEraseLineEvent = Q_NEW(
    Display::Event::DisplayText,
    DISPLAY_TEXT_SIG,
    0, 30,
    0xF,
    &amp;lIPAddressStr[0],
    false
);
QP::QF::PUBLISH(lEraseLineEvent, this);

lEvent-&gt;mIPAddress.GetString(&amp;lIPAddressStr[0]);
Display::Event::DisplayText * const lLwIPChangedEvent = Q_NEW(
    Display::Event::DisplayText,
    DISPLAY_TEXT_SIG,
    0, 30,
    0xF,
    &amp;lIPAddressStr[0],
    true
);
QP::QF::PUBLISH(lLwIPChangedEvent, this);

//LOG_DEBUG(mLogCategory, &amp;lIPAddressStr[0]);
mLogger-&gt;Log(
    LogLevel::prio::DEBUG,
    mLogCategory,
    std::source_location::current(),
    &amp;lIPAddressStr[0]
);</action>
       <tran_glyph conn="4,110,3,-1,50">
        <action box="0,-2,50,2"/>
       </tran_glyph>
      </tran>
      <tran trig="TERMINATE">
       <action brief="Stop();">// Requires QF_ACTIVE_STOP to be defined.
QP::QF::stop();</action>
       <tran_glyph conn="72,12,0,-1,-6,8">
        <action box="0,-6,10,4"/>
       </tran_glyph>
      </tran>
      <tran trig="LWIP_SYSTEM_TIME_UPDATE? 0">
       <action>LwIP::Event::SystemTimeUpdate const * const lEvent = static_cast&lt;LwIP::Event::SystemTimeUpdate const *&gt;(e);
</action>
       <choice>
        <guard brief="UseSystemType == true">mFeedCfgRec-&gt;UseSystemTime() == true</guard>
        <action brief="^RTCC_SET_TIME_AND_DATE(Time, Date)">// Convert to local time.
struct tm * const lTimeInfo = localtime(&amp;lEvent-&gt;mSystemTime);
//struct tm * const lTimeInfo = gmtime(&amp;lEvent-&gt;mSystemTime);

Time lTime(lTimeInfo);
Date lDate(lTimeInfo);

RTCC::Event::TimeAndDate *lEvtPtr = Q_NEW(
    RTCC::Event::TimeAndDate,
    RTCC_SET_TIME_AND_DATE_SIG,
    lTime,
    lDate
);

QP::QF::PUBLISH(lEvtPtr, this);
</action>
        <choice_glyph conn="32,114,5,-1,22">
         <action box="1,-2,33,4"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="4,114,3,-1,28">
        <action box="0,-2,24,2"/>
       </tran_glyph>
      </tran>
      <tran trig="FEED_MGR_LOG? USE_RTT">
       <action brief="ParseEvent();">Logging::Event::LogEntry const * const lEvent = static_cast&lt;Logging::Event::LogEntry const *&gt;(e);
</action>
       <choice>
        <guard brief="Level &lt;= Threshold">lEvent-&gt;mLogLevel &lt;= mLogThreshold</guard>
        <action brief="PrintEvent();">PrintEvent(*lEvent);</action>
        <choice_glyph conn="32,122,5,-1,22">
         <action box="1,-2,25,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="4,122,3,-1,28">
        <action box="0,-2,26,2"/>
       </tran_glyph>
      </tran>
      <state name="Waiting">
       <documentation>// Waiting here for anything to happen.</documentation>
       <entry brief="recall();">recall(&amp;mDeferredEventQueue);</entry>
       <state_glyph node="32,24,44,8">
        <entry box="1,2,13,2"/>
       </state_glyph>
      </state>
      <state name="ManualFeed">
       <documentation>Feeding state triggered by manual action.</documentation>
       <exit brief="StopFeeder(); StopTimer();">StopTimedFeed();</exit>
       <initial target="../3">
        <initial_glyph conn="44,42,5,0,4,4">
         <action box="0,-2,10,2"/>
        </initial_glyph>
       </initial>
       <tran trig="RTCC_CALENDAR_EVENT_ALARM? 0">
        <action brief="Log(); defer();">if (defer(&amp;mDeferredEventQueue, e))
{
    // Event deferred: log event.
} else {
    // Event NOT deferred because of no room in the defer queue: Log event.
}</action>
        <tran_glyph conn="32,70,3,-1,40">
         <action box="0,-2,39,2"/>
        </tran_glyph>
       </tran>
       <tran trig="FEED_MGR_TIMED_FEED_CMD">
        <action brief="DoNothing();">// Intercept this signal discard it.
// We consider this ok since we're already in a timed feeding sequence.</action>
        <tran_glyph conn="32,74,3,-1,40">
         <action box="0,-2,40,2"/>
        </tran_glyph>
       </tran>
       <state name="WaitPeriod">
        <documentation>The wait period before starting the feeder.</documentation>
        <entry brief="StartTimer(WaitTime);">const auto lManualWaitPeriod {GetManualWaitPeriod()};
mFeedTimer.armX(lManualWaitPeriod);</entry>
        <tran trig="FEED_MGR_TIMEOUT" target="../../4">
         <tran_glyph conn="42,50,3,3,-4,12,4">
          <action box="-4,5,20,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="42,46,30,8">
         <entry box="1,2,22,2"/>
        </state_glyph>
       </state>
       <state name="TimedCappedFeed">
        <documentation>The feeding state for a manual feed.
Has a time limit to avoid over-feeding and emptying the feeder.</documentation>
        <entry brief="StartTimer(MaxFeedTime); StartFeeder();">const auto lManualMaxFeedPeriod {GetManualMaxFeedPeriod()};
StartTimedFeed(lManualMaxFeedPeriod);</entry>
        <exit brief="DisplayFeedTime();">#if 0
DisplayFeedTime();
//LOG_DEBUG(mLogCategory, &quot;Manual feed.&quot;);
mLogger-&gt;Log(
    LogLevel::prio::DEBUG,
    mLogCategory,
    std::source_location::current(),
    &quot;Manual feed.&quot;
);
#endif</exit>
        <state_glyph node="42,58,30,8">
         <entry box="1,2,25,4"/>
         <exit box="1,6,25,2"/>
        </state_glyph>
       </state>
       <state_glyph node="32,36,44,42">
        <exit box="1,2,13,4"/>
       </state_glyph>
      </state>
      <state name="TimedFeed">
       <documentation>State describing behavior for events triggering a fixed timed feeding period.</documentation>
       <entry brief="StartTimer(FeedTime); StartFeeder();">const auto lTimedFeedPeriod {GetTimedFeedPeriod()};
StartTimedFeed(lTimedFeedPeriod);</entry>
       <exit brief="StopFeeder(); StopTimer(); DisplayFeedTime();">StopTimedFeed();
#if 0
DisplayFeedTime();
mLogger-&gt;Log(
    LogLevel::prio::DEBUG,
    mLogCategory,
    std::source_location::current(),
    &quot;Timed feed.&quot;
);
#endif</exit>
       <tran trig="RTCC_CALENDAR_EVENT_ALARM? 0">
        <action brief="Log(); defer();">if (defer(&amp;mDeferredEventQueue, e))
{
    // Event deferred: log event.
} else {
    // Event NOT deferred because of no room in the defer queue: Log event.
}</action>
        <tran_glyph conn="32,92,3,-1,40">
         <action box="0,-2,40,2"/>
        </tran_glyph>
       </tran>
       <tran trig="FEED_MGR_MANUAL_FEED_CMD">
        <action brief="DoNothing();">// Discard any manual feeding action while we're already in a timed feeding sequence.</action>
        <tran_glyph conn="32,96,3,-1,40">
         <action box="0,-2,40,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="32,82,44,18">
        <entry box="1,2,31,2"/>
        <exit box="1,4,39,2"/>
       </state_glyph>
      </state>
      <state_glyph node="4,12,76,116">
       <entry box="1,2,17,2"/>
      </state_glyph>
     </state>
     <state_diagram size="84,132"/>
    </statechart>
   </class>
   <class name="BLE_AO" superclass="qpcpp::QActive">
    <documentation>The active object for the Bluetooth Low Energy (BLE).

Exchange data with the BLE module via SPI.</documentation>
    <attribute name="mBLE" type="BLE::IBLE &amp;" visibility="0x02" properties="0x00">
     <documentation>Reference to a IBLE-compatible interface.</documentation>
    </attribute>
    <operation name="BLE_AO" type="" visibility="0x00" properties="0x00">
     <documentation>Ctor.</documentation>
     <parameter name="aBLE" type="BLE::IBLE &amp;"/>
     <code>    : QP::QActive(Q_STATE_CAST(&amp;PFPP::AO::BLE_AO::initial))
    , mBLE(aBLE)

// Ctor body.</code>
    </operation>
    <statechart properties="0x02">
     <initial target="../1">
      <action brief="Init();">PFPP::Event::BLE::Init const * const lInitEvent = static_cast&lt;PFPP::Event::BLE::Init const * const&gt;(e);
mBLE.Init(lInitEvent-&gt;mRTCC_AO, lInitEvent-&gt;mCalendarRec, lInitEvent-&gt;mNetIFRec, lInitEvent-&gt;mFeedCfgRec);
</action>
      <initial_glyph conn="4,2,5,0,4,6">
       <action box="0,-2,10,2"/>
      </initial_glyph>
     </initial>
     <state name="Running">
      <documentation>The top Running state.</documentation>
      <tran trig="TERMINATE">
       <action brief="Stop();">// Requires QF_ACTIVE_STOP to be defined.
stop();</action>
       <tran_glyph conn="24,8,0,-1,-6,8">
        <action box="0,-5,11,4"/>
       </tran_glyph>
      </tran>
      <tran trig="BLE_INTERRUPT">
       <action brief="ReadStatus();">// Read status back from BLE host peripheral.
</action>
       <tran_glyph conn="4,14,3,-1,24">
        <action box="0,-2,22,4"/>
       </tran_glyph>
      </tran>
      <state_glyph node="4,8,28,16"/>
     </state>
     <state_diagram size="36,28"/>
    </statechart>
   </class>
  </package>
  <package name="Events" stereotype="0x01" namespace="Event::">
   <package name="Mgr" stereotype="0x01" namespace="Mgr::">
    <class name="Init" superclass="qpcpp::QEvt">
     <documentation>Init event to pass to pseudo initial transition.</documentation>
     <attribute name="mFeedCfg" type="const FeedCfg&amp;" visibility="0x00" properties="0x00">
      <documentation>A reference to the FeedCfg.</documentation>
     </attribute>
    </class>
    <class name="ManualFeedCmd" superclass="qpcpp::QEvt">
     <documentation>An event for manual feed commands.</documentation>
     <attribute name="mIsActive" type="bool" visibility="0x00" properties="0x00">
      <documentation>The state of the command: true when on, false when off.</documentation>
     </attribute>
    </class>
    <class name="TimedFeedCmd" superclass="qpcpp::QEvt">
     <documentation>An event for timed feed commands.</documentation>
     <attribute name="mDuration? 0" type="QP::QTimeEvtCtr" visibility="0x00" properties="0x00">
      <documentation>An event for timed event commands.</documentation>
     </attribute>
    </class>
   </package>
   <package name="BLE" stereotype="0x01" namespace="BLE::">
    <class name="Init" superclass="qpcpp::QEvt">
     <documentation>Init event to pass to pseudo initial transition.</documentation>
     <attribute name="mRTCC_AO" type="std::shared_ptr&lt;RTCC::AO::RTCC_AO&gt; const" visibility="0x00" properties="0x00"/>
     <attribute name="mCalendarRec" type="CalendarRec * const" visibility="0x00" properties="0x00">
      <documentation>Pointer to Calendar record.</documentation>
     </attribute>
     <attribute name="mNetIFRec" type="NetIFRec * const" visibility="0x00" properties="0x00">
      <documentation>Pointer to Net IF record.</documentation>
     </attribute>
     <attribute name="mFeedCfgRec" type="FeedCfgRec * const" visibility="0x00" properties="0x00">
      <documentation>Pointer to Feeding config record.</documentation>
     </attribute>
     <operation name="Init" type="" visibility="0x00" properties="0x02">
      <documentation>// Event ctor.</documentation>
      <parameter name="aSig" type="QP::QSignal const"/>
      <parameter name="aRTCC_AO" type="std::shared_ptr&lt;RTCC::AO::RTCC_AO&gt; const"/>
      <parameter name="aCalendarRec" type="CalendarRec * const"/>
      <parameter name="aNetIFRec" type="NetIFRec * const"/>
      <parameter name="aFeedCfgRec" type="FeedCfgRec * const"/>
      <code>    : QP::QEvt(aSig)
    , mRTCC_AO(aRTCC_AO)
    , mCalendarRec(aCalendarRec)
    , mNetIFRec(aNetIFRec)
    , mFeedCfgRec(aFeedCfgRec)

// Ctor body.</code>
     </operation>
    </class>
   </package>
  </package>
  <directory name="../codegen">
   <file name="PFPP_Events.h">
    <text>// QP.
#include &lt;qpcpp.hpp&gt;


$declare${project::Events::Mgr::ManualFeedCmd}
$declare${project::Events::Mgr::TimedFeedCmd}
$declare${project::Events::Mgr::Init}
</text>
   </file>
   <file name="PFPP_AOs.h">
    <text>// Standard Library.
#include &lt;chrono&gt;
#include &lt;memory&gt;

// QP.
#include &lt;qpcpp.hpp&gt;

// QM Project.
#include &quot;Utils.h&quot;

// This project.
#include &quot;inc/FeedCfg.h&quot;
//#include &quot;drivers/inc/IMotorControl.h&quot;

// Forward declarations.
namespace Drivers
{
    class IMotorControl;
}


$declare${project::AOs::Mgr_AO}
</text>
   </file>
   <file name="PFPP_AOs.cpp">
    <text>// Standard libraries.
#include &lt;time.h&gt;

#ifdef USE_RTT
// SEGGER RTT.
#include &lt;SEGGER_RTT.h&gt;
#endif // USE_RTT

// Drivers.
#include &quot;drivers/inc/IMotorControl.h&quot;

// This project.
#include &quot;qp_ao/codegen/PFPP_AOs.h&quot;
#include &quot;qp_ao/codegen/PFPP_Events.h&quot;
#include &quot;qp_ao/codegen/Signals.h&quot;


$define${project::AOs::Mgr_AO}
</text>
   </file>
   <file name="BLE_Events.h">
    <text>#include &lt;qpcpp.h&gt;


// Add Init event here if ever needed.
$declare${project::Events::BLE::Init}
</text>
   </file>
   <file name="BLE_AOs.h">
    <text>#include &lt;qpcpp.h&gt;


#include &quot;BLE.h&quot;
//#include &lt;db/FeedCfgRec.h&gt;


$declare${project::AOs::BLE_AO}
</text>
   </file>
   <file name="BLE_AOs.cpp">
    <text>#include &quot;BSP.h&quot;
#include &quot;Signals.h&quot;

//#include &quot;net/IPAddress.h&quot;

//#include &quot;Display_Events.h&quot;
//#include &quot;LwIP_Events.h&quot;
//#include &quot;RTCC_Events.h&quot;
//#include &quot;Logger.h&quot;

#include &quot;BLE_AOs.h&quot;
#include &quot;BLE_Events.h&quot;


$define${project::AOs::BLE_AO}
</text>
   </file>
   <file name="Signals.h">
    <text>#ifndef PFPPCODEGEN__SIGNALS_H_
#define PFPPCODEGEN__SIGNALS_H_

// Signals definitions for all packages in the project.

#include &lt;qpcpp.hpp&gt;


enum Signals
{
    FEED_MGR_TIMEOUT_SIG = QP::Q_USER_SIG,
    FEED_MGR_MANUAL_FEED_CMD_SIG,
    FEED_MGR_TIMED_FEED_CMD_SIG,
    FEED_MGR_LOG_SIG,
    FEED_MGR_LAST_SIG,

    RTCC_TICK_SIG,
    RTCC_ALARM_SIG,
    RTCC_SET_TIME_SIG,
    RTCC_SET_DATE_SIG,
    RTCC_SET_TIME_AND_DATE_SIG,
    RTCC_SET_ALARM_SIG,
    RTCC_INTERRUPT_SIG,
    RTCC_SAVE_TO_NV_MEM_SIG, // TODO: remove

    TERMINATE_SIG,
    QTY_SIG

};


#endif // PFPPCODEGEN__SIGNALS_H_
</text>
   </file>
   <file name="Utils.h">
    <text>#ifndef PFPPCODEGEN__UTILS_H_
#define PFPPCODEGEN__UTILS_H_


#include &lt;qpcpp.hpp&gt;

#include &lt;chrono&gt;

// Define function type to return number of ticks.
using ToTicksFct = QP::QTimeEvtCtr (*)(std::chrono::milliseconds);


#endif // PFPPCODEGEN__UTILS_H_
</text>
   </file>
  </directory>
 </package>
 <package file="./rtcc.qmp"/>
</model>
